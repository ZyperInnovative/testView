<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fixed Crypto Blockchain Background</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: auto;
      background: #0a0a1a;
      color: white;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    #blockchain {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      opacity: 0.9;
    }

    .loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 1.5rem;
      color: #627eea;
      background: rgba(10, 10, 26, 0.8);
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 0 20px rgba(98, 126, 234, 0.5);
    }

    .content {
      padding: 2rem;
      max-width: 800px;
      margin: 0 auto;
      background-color: rgba(10, 10, 26, 0.7);
      border-radius: 8px;
      margin-top: 50px;
      backdrop-filter: blur(5px);
    }

    .crypto-tooltip {
      position: absolute;
      background: rgba(20, 20, 40, 0.9);
      border: 1px solid #627eea;
      border-radius: 8px;
      padding: 10px;
      pointer-events: none;
      z-index: 100;
      font-size: 14px;
      max-width: 200px;
      backdrop-filter: blur(5px);
      box-shadow: 0 0 15px rgba(98, 126, 234, 0.4);
      opacity: 0;
      transition: opacity 0.3s;
    }
  </style>
</head>
<body>
  <canvas id="blockchain"></canvas>
  <div class="loading" id="loading">Loading crypto data...</div>
  <div class="crypto-tooltip" id="tooltip"></div>
  
  

  <script>
    // Main configuration
    const config = {
      maxNodes: 25,
      nodeSpeed: 0.1,
      connectionDistance: 250,
      updateInterval: 120000 // 2 minutes
    };

    // DOM elements
    const canvas = document.getElementById("blockchain");
    const ctx = canvas.getContext("2d");
    const loadingElement = document.getElementById("loading");
    const tooltipElement = document.getElementById("tooltip");

    // Initialize canvas
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resizeCanvas();

    // Crypto data storage
    const cryptoData = {};
    const nodes = [];
    let hoveredNode = null;

    // Crypto symbol fallbacks with fixed colors
    const cryptoSymbols = {
      bitcoin: { symbol: "₿", color: "rgba(247, 147, 26, 0.8)" },
      ethereum: { symbol: "Ξ", color: "rgba(98, 126, 234, 0.8)" },
      tether: { symbol: "₮", color: "rgba(38, 161, 123, 0.8)" },
      "binancecoin": { symbol: "ⓑ", color: "rgba(243, 186, 47, 0.8)" },
      ripple: { symbol: "✕", color: "rgba(39, 162, 219, 0.8)" },
      solana: { symbol: "◎", color: "rgba(20, 241, 149, 0.8)" },
      cardano: { symbol: "ⓐ", color: "rgba(0, 51, 173, 0.8)" },
      dogecoin: { symbol: "Ð", color: "rgba(203, 152, 0, 0.8)" },
      polkadot: { symbol: "●", color: "rgba(230, 0, 122, 0.8)" },
      "shiba-inu": { symbol: "ⓢ", color: "rgba(255, 0, 84, 0.8)" }
    };

    // Convert hex to rgba with opacity
    function hexToRgba(hex, opacity) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return `rgba(${r}, ${g}, ${b}, ${opacity})`;
    }

    // Generate random color with fixed opacity
    function generateRandomColor() {
      const hue = Math.floor(Math.random() * 360);
      return `hsla(${hue}, 70%, 50%, 0.8)`;
    }

    // Load crypto data from CoinGecko API
    async function fetchCryptoData() {
      try {
        const response = await fetch("https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=50&page=1&sparkline=false&price_change_percentage=24h");
        const data = await response.json();
        
        // Process the data
        data.forEach(coin => {
          cryptoData[coin.id] = {
            name: coin.name,
            symbol: coin.symbol,
            current_price: coin.current_price,
            price_change_percentage_24h: coin.price_change_percentage_24h,
            image: coin.image,
            color: cryptoSymbols[coin.id]?.color || generateRandomColor(),
            market_cap: coin.market_cap
          };
        });

        // Create nodes after data is loaded
        createNodes();
        loadingElement.style.display = 'none';
        setTimeout(updatePrices, config.updateInterval);
      } catch (error) {
        console.error("Error fetching crypto data:", error);
        loadingElement.textContent = "Failed to load crypto data. Using simulated data.";
        createSimulatedNodes();
      }
    }

    // Create nodes with real crypto data
    function createNodes() {
      const cryptoIds = Object.keys(cryptoData);
      
      for (let i = 0; i < config.maxNodes; i++) {
        const cryptoId = cryptoIds[i % cryptoIds.length];
        const crypto = cryptoData[cryptoId];
        
        const img = new Image();
        img.src = crypto.image;
        
        nodes.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          size: calculateNodeSize(crypto.market_cap),
          dx: (Math.random() - 0.5) * config.nodeSpeed,
          dy: (Math.random() - 0.5) * config.nodeSpeed,
          image: img,
          symbol: cryptoSymbols[cryptoId]?.symbol || crypto.symbol.toUpperCase(),
          color: crypto.color,
          value: crypto.price_change_percentage_24h.toFixed(2) + "%",
          rawValue: crypto.price_change_percentage_24h,
          alpha: 0.7 + Math.random() * 0.3,
          id: cryptoId,
          name: crypto.name,
          price: formatPrice(crypto.current_price)
        });
      }
    }

    // Calculate node size based on market cap
    function calculateNodeSize(marketCap) {
      const minSize = 15;
      const maxSize = 40;
      const minCap = 1e9; // 1 billion
      const maxCap = 1e12; // 1 trillion
      
      if (marketCap < minCap) return minSize;
      if (marketCap > maxCap) return maxSize;
      
      const scale = Math.log(marketCap) - Math.log(minCap);
      const maxScale = Math.log(maxCap) - Math.log(minCap);
      return minSize + (maxSize - minSize) * (scale / maxScale);
    }

    // Format price
    function formatPrice(price) {
      if (price >= 1) {
        return "$" + price.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
      } else {
        return "$" + price.toFixed(6).replace(/\.?0+$/, "");
      }
    }

    // Create simulated nodes (fallback)
    function createSimulatedNodes() {
      const cryptos = Object.entries(cryptoSymbols);
      
      for (let i = 0; i < config.maxNodes; i++) {
        const [id, crypto] = cryptos[i % cryptos.length];
        const change = (Math.random() > 0.5 ? 1 : -1) * (Math.random() * 15);
        
        nodes.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          size: Math.random() * 20 + 15,
          dx: (Math.random() - 0.5) * config.nodeSpeed,
          dy: (Math.random() - 0.5) * config.nodeSpeed,
          image: null,
          symbol: crypto.symbol,
          color: crypto.color,
          value: (change > 0 ? "+" : "") + change.toFixed(2) + "%",
          rawValue: change,
          alpha: 0.7 + Math.random() * 0.3,
          id: "simulated-" + id,
          name: id.charAt(0).toUpperCase() + id.slice(1),
          price: "$" + (Math.random() * 10000).toFixed(2)
        });
      }
      
      setTimeout(() => {
        loadingElement.style.display = 'none';
      }, 2000);
    }

    // Update prices
    async function updatePrices() {
      try {
        const response = await fetch("https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=50&page=1&sparkline=false&price_change_percentage=24h");
        const data = await response.json();
        
        // Create a mapping of new data
        const newData = {};
        data.forEach(coin => {
          newData[coin.id] = {
            price_change_percentage_24h: coin.price_change_percentage_24h,
            current_price: coin.current_price
          };
        });

        // Update our nodes
        nodes.forEach(node => {
          if (newData[node.id]) {
            const change = newData[node.id].price_change_percentage_24h;
            node.rawValue = change;
            node.value = (change > 0 ? "+" : "") + change.toFixed(2) + "%";
            node.price = formatPrice(newData[node.id].current_price);
            
            // Visual feedback for significant changes
            if (Math.abs(change) > 5) {
              node.size = calculateNodeSize(cryptoData[node.id]?.market_cap || 1e10) * 1.2;
              setTimeout(() => {
                node.size = calculateNodeSize(cryptoData[node.id]?.market_cap || 1e10);
              }, 1000);
            }
          }
        });
      } catch (error) {
        console.error("Error updating prices:", error);
      }
      
      // Schedule next update
      setTimeout(updatePrices, config.updateInterval);
    }

    // Draw a crypto node
    function drawNode(node) {
      // Draw connection glow first if hovered
      if (node === hoveredNode) {
        drawNodeGlow(node, node.size * 2.5, 0.3);
      }

      // Draw the image if loaded, otherwise fallback to symbol
      if (node.image && node.image.complete && node.image.naturalWidth !== 0) {
        ctx.save();
        ctx.globalAlpha = node.alpha;
        ctx.drawImage(
          node.image, 
          node.x - node.size/2, 
          node.y - node.size/2, 
          node.size, 
          node.size
        );
        ctx.restore();
      } else {
        // Fallback to symbol
        ctx.save();
        ctx.globalAlpha = node.alpha;
        ctx.font = `${node.size}px Arial`;
        ctx.fillStyle = node.color;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(node.symbol, node.x, node.y);
        ctx.restore();
      }
      
      // Draw percentage
      ctx.font = `${node.size/2}px Arial`;
      ctx.fillStyle = node.rawValue >= 0 ? "rgba(0, 255, 170, 0.8)" : "rgba(255, 85, 85, 0.8)";
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      ctx.fillText(node.value, node.x, node.y + node.size/2 + 5);
      
      // Random glow effect
      if (Math.random() > 0.95) {
        drawNodeGlow(node, node.size * 1.5, 0.2);
      }
    }

    // Draw glow around a node (fixed color handling)
    function drawNodeGlow(node, radius, intensity) {
      const gradient = ctx.createRadialGradient(
        node.x, node.y, node.size/2,
        node.x, node.y, radius
      );
      
      // Extract base color without alpha
      let baseColor = node.color;
      if (baseColor.startsWith('rgba')) {
        baseColor = baseColor.substring(0, baseColor.lastIndexOf(',')) + ')';
      } else if (baseColor.startsWith('hsla')) {
        baseColor = `hsl${baseColor.substring(4, baseColor.lastIndexOf(','))})`;
      }
      
      gradient.addColorStop(0, baseColor.replace(')', `, ${intensity})`));
      gradient.addColorStop(1, baseColor.replace(')', `, 0)`));
      
      ctx.beginPath();
      ctx.arc(node.x, node.y, radius, 0, Math.PI * 2);
      ctx.fillStyle = gradient;
      ctx.fill();
    }

    // Draw connections between nodes (fixed color handling)
    function drawConnections() {
      for (let i = 0; i < nodes.length; i++) {
        for (let j = i + 1; j < nodes.length; j++) {
          const node1 = nodes[i];
          const node2 = nodes[j];
          const dx = node1.x - node2.x;
          const dy = node1.y - node2.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < config.connectionDistance) {
            const opacity = 0.5 - (distance / config.connectionDistance) * 0.4;
            
            // Highlight connections to hovered node
            const isConnectedToHovered = hoveredNode && 
              (node1 === hoveredNode || node2 === hoveredNode);
            
            if (isConnectedToHovered) {
              ctx.lineWidth = 1.5;
              ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 2})`;
            } else {
              ctx.lineWidth = 0.5;
              
              // Use solid color instead of gradient for stability
              const midOpacity = opacity * 0.7;
              ctx.strokeStyle = `rgba(100, 150, 255, ${midOpacity})`;
            }
            
            ctx.beginPath();
            ctx.moveTo(node1.x, node1.y);
            ctx.lineTo(node2.x, node2.y);
            ctx.stroke();
          }
        }
      }
    }

    // Update node positions
    function updateNodes() {
      for (let node of nodes) {
        node.x += node.dx;
        node.y += node.dy;

        // Wrap around edges with padding
        const padding = node.size * 2;
        if (node.x < -padding) node.x = canvas.width + padding;
        if (node.x > canvas.width + padding) node.x = -padding;
        if (node.y < -padding) node.y = canvas.height + padding;
        if (node.y > canvas.height + padding) node.y = -padding;
        
        // Random alpha variation for twinkling effect
        if (Math.random() > 0.98) {
          node.alpha = 0.7 + Math.random() * 0.3;
        }
      }
    }

    // Handle mouse movement for hover effects
    function handleMouseMove(e) {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      
      let closestNode = null;
      let closestDistance = Infinity;
      
      // Find closest node to mouse position
      for (const node of nodes) {
        const dx = mouseX - node.x;
        const dy = mouseY - node.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < node.size * 1.5 && distance < closestDistance) {
          closestDistance = distance;
          closestNode = node;
        }
      }
      
      // Update hover state
      if (hoveredNode !== closestNode) {
        hoveredNode = closestNode;
        updateTooltip();
      }
    }

    // Update tooltip position and content
    function updateTooltip() {
      if (hoveredNode) {
        tooltipElement.style.opacity = '1';
        tooltipElement.style.left = `${hoveredNode.x + 20}px`;
        tooltipElement.style.top = `${hoveredNode.y}px`;
        
        tooltipElement.innerHTML = `
          <div style="font-weight: bold; margin-bottom: 5px; color: #f7931a;">${hoveredNode.name}</div>
          <div>Price: ${hoveredNode.price}</div>
          <div style="font-weight: bold; color: ${hoveredNode.rawValue >= 0 ? '#00ffaa' : '#ff5555'}">
            24h Change: ${hoveredNode.value}
          </div>
        `;
      } else {
        tooltipElement.style.opacity = '0';
      }
    }

    // Main animation loop
    function animate() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      drawConnections();
      for (let node of nodes) {
        drawNode(node);
      }

      updateNodes();

      requestAnimationFrame(animate);
    }

    // Event listeners
    window.addEventListener("resize", resizeCanvas);
    canvas.addEventListener("mousemove", handleMouseMove);
    canvas.addEventListener("mouseout", () => {
      hoveredNode = null;
      tooltipElement.style.opacity = '0';
    });

    // Initialize
    fetchCryptoData();
    animate();
  </script>
</body>
</html>