<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Secure Multi-CAPTCHA Verification</title>
    <meta name="description" content="Advanced anti-bot protection with multiple verification methods">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; media-src 'self'">
    <style>
        :root {
            --primary: #4361ee;
            --secondary: #3a0ca3;
            --success: #4cc9f0;
            --danger: #f72585;
            --warning: #f8961e;
            --light: #f8f9fa;
            --dark: #212529;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
            color: var(--light);
        }
        
        .security-badge {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            animation: pulse 2s infinite;
        }
        
        .verification-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 2rem;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 500px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }
        
        .verification-container:hover {
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        h1 {
            color: var(--light);
            margin-bottom: 1.5rem;
            font-weight: 600;
        }
        
        .method-title {
            font-size: 1.2rem;
            margin-bottom: 1.5rem;
            color: var(--success);
            font-weight: 500;
        }
        
        /* Voice CAPTCHA styles */
        .voice-captcha {
            display: none;
        }
        
        .captcha-word {
            font-size: 1.8rem;
            margin: 1.5rem 0;
            font-weight: bold;
            letter-spacing: 2px;
            color: var(--light);
            background: rgba(0, 0, 0, 0.3);
            padding: 0.5rem 1rem;
            border-radius: 8px;
            display: inline-block;
        }
        
        .hold-button {
            background: var(--primary);
            color: white;
            border: none;
            padding: 0.8rem 2rem;
            font-size: 1rem;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
            box-shadow: 0 4px 15px rgba(67, 97, 238, 0.4);
            margin: 0.5rem 0;
            width: 80%;
            max-width: 250px;
        }
        
        .hold-button:hover {
            background: var(--secondary);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(67, 97, 238, 0.6);
        }
        
        .hold-button:active {
            transform: translateY(0);
        }
        
        .hold-button.listening {
            background: var(--danger);
            animation: pulse 1.5s infinite;
        }
        
        /* Math CAPTCHA styles */
        .math-captcha {
            display: none;
        }
        
        .math-problem {
            font-size: 1.5rem;
            margin: 1.5rem 0;
            color: var(--light);
        }
        
        .math-input {
            padding: 0.8rem;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.1);
            color: var(--light);
            font-size: 1rem;
            width: 80px;
            text-align: center;
            margin: 0 0.5rem;
        }
        
        /* Image CAPTCHA styles */
        .image-captcha {
            display: none;
        }
        
        .image-options {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin: 1.5rem 0;
        }
        
        .image-option {
            width: 100px;
            height: 100px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            object-fit: cover;
            border: 2px solid transparent;
        }
        
        .image-option:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        
        .image-option.selected {
            border: 2px solid var(--success);
            box-shadow: 0 0 15px rgba(76, 201, 240, 0.5);
        }
        
        .message {
            margin: 1.5rem 0;
            padding: 0.8rem;
            border-radius: 8px;
            font-weight: 500;
        }
        
        .success {
            background: rgba(76, 201, 240, 0.2);
            color: var(--success);
            border: 1px solid var(--success);
        }
        
        .error {
            background: rgba(247, 37, 133, 0.2);
            color: var(--danger);
            border: 1px solid var(--danger);
        }
        
        .loading-container {
            display: none;
            flex-direction: column;
            align-items: center;
            margin: 1.5rem 0;
        }
        
        .loading-text {
            margin-bottom: 1rem;
            font-size: 1.1rem;
            color: var(--light);
        }
        
        .loader {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top: 4px solid var(--success);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        
        .switch-method {
            margin-top: 1rem;
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.9rem;
            cursor: pointer;
            text-decoration: underline;
        }
        
        .switch-method:hover {
            color: var(--light);
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .attempts-warning {
            color: var(--warning);
            font-size: 0.9rem;
            margin-top: 1rem;
            display: none;
        }
        
        .security-footer {
            margin-top: 2rem;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.5);
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="security-badge">üõ°Ô∏è</div>
    <div class="verification-container">
        <h1>Human Verification</h1>
        <div class="method-title" id="method-title">Voice Verification</div>
        
        <!-- Voice CAPTCHA -->
        <div class="voice-captcha" id="voice-captcha">
            <div class="captcha-word" id="captcha-word"></div>
            <button class="hold-button" id="hold-button">Hold to Speak</button>
            <div class="switch-method" onclick="switchMethod()">Try another method</div>
        </div>
        
        <!-- Math CAPTCHA -->
        <div class="math-captcha" id="math-captcha">
            <div class="math-problem" id="math-problem"></div>
            <input type="number" class="math-input" id="math-answer" placeholder="Answer">
            <button class="hold-button" onclick="checkMathAnswer()">Verify</button>
            <div class="switch-method" onclick="switchMethod()">Try another method</div>
        </div>
        
        <!-- Image CAPTCHA -->
        <div class="image-captcha" id="image-captcha">
            <div id="image-instruction">Select all images containing <span id="image-target"></span></div>
            <div class="image-options" id="image-options"></div>
            <button class="hold-button" onclick="checkImageSelection()">Verify Selection</button>
            <div class="switch-method" onclick="switchMethod()">Try another method</div>
        </div>
        
        <div class="message" id="message"></div>
        <div class="attempts-warning" id="attempts-warning"></div>
        
        <div class="loading-container" id="loading-container">
            <div class="loading-text">Verifying your response...</div>
            <div class="loader"></div>
        </div>
    </div>
    
    <div class="security-footer">
        Protected by Sentinel Security ‚Ä¢ <span id="timestamp"></span>
    </div>

    <script>
        // Configuration
        const config = {
            maxAttempts: 3,
            successRedirect: 'xyzDashboard.html',
            voiceWords: ['satoshi', 'blockchain', 'bitcoin', 'ethereum', 'crypto', 'decentralized'],
            imageCategories: {
                'vehicles': ['üöó', 'üöï', 'üöô', 'üöå', 'üöé', 'üèéÔ∏è', 'üöì', 'üöë'],
                'animals': ['üê∂', 'üê±', 'üê≠', 'üêπ', 'üê∞', 'ü¶ä', 'üêª', 'üêº'],
                'food': ['üçé', 'üçê', 'üçä', 'üçã', 'üçå', 'üçâ', 'üçá', 'üçì']
            },
            methods: ['voice', 'math', 'image'] // Available CAPTCHA methods
        };
        
        // State management
        let state = {
            currentMethod: '',
            currentWord: '',
            mathProblem: { num1: 0, num2: 0, operator: '+', answer: 0 },
            imageTarget: '',
            correctImages: [],
            selectedImages: [],
            attempts: 0,
            usedMethods: []
        };
        
        // DOM elements
        const elements = {
            voiceCaptcha: document.getElementById('voice-captcha'),
            mathCaptcha: document.getElementById('math-captcha'),
            imageCaptcha: document.getElementById('image-captcha'),
            captchaWord: document.getElementById('captcha-word'),
            holdButton: document.getElementById('hold-button'),
            mathProblem: document.getElementById('math-problem'),
            mathAnswer: document.getElementById('math-answer'),
            imageTarget: document.getElementById('image-target'),
            imageOptions: document.getElementById('image-options'),
            message: document.getElementById('message'),
            methodTitle: document.getElementById('method-title'),
            loadingContainer: document.getElementById('loading-container'),
            attemptsWarning: document.getElementById('attempts-warning'),
            timestamp: document.getElementById('timestamp')
        };
        
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            // Set timestamp
            elements.timestamp.textContent = new Date().toLocaleString();
            
            // Initialize voice recognition if available
            if (!('webkitSpeechRecognition' in window)) {
                // Remove voice from available methods if not supported
                config.methods = config.methods.filter(method => method !== 'voice');
            }
            
            // Start with a random method
            selectRandomMethod();
            
            // Button hold functionality for voice CAPTCHA
            if (elements.holdButton) {
                elements.holdButton.addEventListener('mousedown', startVoiceRecognition);
                elements.holdButton.addEventListener('touchstart', startVoiceRecognition);
                elements.holdButton.addEventListener('mouseup', stopVoiceRecognition);
                elements.holdButton.addEventListener('touchend', stopVoiceRecognition);
                elements.holdButton.addEventListener('mouseleave', stopVoiceRecognition);
            }
        });
        
        // Method selection
        function selectRandomMethod() {
            // Filter out methods that have already been used
            const availableMethods = config.methods.filter(method => !state.usedMethods.includes(method));
            
            // If all methods have been tried, reset the used methods
            if (availableMethods.length === 0) {
                state.usedMethods = [];
                availableMethods.push(...config.methods);
            }
            
            // Select a random method from available ones
            state.currentMethod = availableMethods[Math.floor(Math.random() * availableMethods.length)];
            state.usedMethods.push(state.currentMethod);
            
            // Hide all methods first
            elements.voiceCaptcha.style.display = 'none';
            elements.mathCaptcha.style.display = 'none';
            elements.imageCaptcha.style.display = 'none';
            
            // Initialize the selected method
            switch(state.currentMethod) {
                case 'voice':
                    initVoiceCaptcha();
                    break;
                case 'math':
                    initMathCaptcha();
                    break;
                case 'image':
                    initImageCaptcha();
                    break;
            }
            
            // Reset message
            elements.message.textContent = '';
            elements.message.className = 'message';
        }
        
        function switchMethod() {
            state.attempts++;
            updateAttemptsWarning();
            selectRandomMethod();
        }
        
        // Voice CAPTCHA functions
        function initVoiceCaptcha() {
            state.currentWord = config.voiceWords[Math.floor(Math.random() * config.voiceWords.length)];
            elements.captchaWord.textContent = state.currentWord;
            elements.voiceCaptcha.style.display = 'block';
            elements.methodTitle.textContent = 'Voice Verification';
        }
        
        function startVoiceRecognition() {
            if (state.currentMethod !== 'voice') return;
            
            elements.holdButton.classList.add('listening');
            elements.holdButton.textContent = 'Listening...';
            
            const recognition = new webkitSpeechRecognition();
            recognition.continuous = false;
            recognition.lang = 'en-US';
            recognition.interimResults = false;
            
            recognition.onstart = function() {
                elements.message.textContent = 'Listening... Please say the word above.';
                elements.message.className = 'message';
            };
            
            recognition.onerror = function(event) {
                elements.message.textContent = 'Error: ' + event.error;
                elements.message.className = 'message error';
                elements.holdButton.classList.remove('listening');
                elements.holdButton.textContent = 'Hold to Speak';
            };
            
            recognition.onresult = function(event) {
                const spokenWord = event.results[0][0].transcript.toLowerCase().trim();
                validateResponse(spokenWord);
            };
            
            recognition.onend = function() {
                elements.holdButton.classList.remove('listening');
                elements.holdButton.textContent = 'Hold to Speak';
            };
            
            recognition.start();
        }
        
        function stopVoiceRecognition() {
            // The recognition will stop automatically when user releases the button
        }
        
        // Math CAPTCHA functions
        function initMathCaptcha() {
            // Generate a simple math problem
            state.mathProblem.num1 = Math.floor(Math.random() * 10) + 1;
            state.mathProblem.num2 = Math.floor(Math.random() * 10) + 1;
            
            // Random operator (+, -, *)
            const operators = ['+', '-', '*'];
            state.mathProblem.operator = operators[Math.floor(Math.random() * operators.length)];
            
            // Calculate answer
            switch(state.mathProblem.operator) {
                case '+':
                    state.mathProblem.answer = state.mathProblem.num1 + state.mathProblem.num2;
                    break;
                case '-':
                    state.mathProblem.answer = state.mathProblem.num1 - state.mathProblem.num2;
                    break;
                case '*':
                    state.mathProblem.answer = state.mathProblem.num1 * state.mathProblem.num2;
                    break;
            }
            
            elements.mathProblem.textContent = `${state.mathProblem.num1} ${state.mathProblem.operator} ${state.mathProblem.num2} = ?`;
            elements.mathAnswer.value = '';
            elements.mathCaptcha.style.display = 'block';
            elements.methodTitle.textContent = 'Math Verification';
        }
        
        function checkMathAnswer() {
            const userAnswer = parseInt(elements.mathAnswer.value);
            if (isNaN(userAnswer)) {
                elements.message.textContent = 'Please enter a valid number';
                elements.message.className = 'message error';
                return;
            }
            
            validateResponse(userAnswer.toString());
        }
        
        // Image CAPTCHA functions
        function initImageCaptcha() {
            // Select a random category
            const categories = Object.keys(config.imageCategories);
            const randomCategory = categories[Math.floor(Math.random() * categories.length)];
            state.imageTarget = randomCategory;
            
            // Get all emojis for this category
            const allEmojis = config.imageCategories[randomCategory];
            
            // Select 3-5 correct images
            const correctCount = Math.floor(Math.random() * 3) + 3;
            state.correctImages = [];
            
            // Shuffle array and pick first 'correctCount' items
            const shuffled = [...allEmojis].sort(() => 0.5 - Math.random());
            state.correctImages = shuffled.slice(0, correctCount);
            
            // Create options (correct + some incorrect)
            const options = [...state.correctImages];
            
            // Add incorrect options from other categories
            const otherCategories = categories.filter(cat => cat !== randomCategory);
            const incorrectPerCategory = Math.ceil((12 - correctCount) / otherCategories.length);
            
            otherCategories.forEach(cat => {
                const incorrectOptions = [...config.imageCategories[cat]]
                    .sort(() => 0.5 - Math.random())
                    .slice(0, incorrectPerCategory);
                options.push(...incorrectOptions);
            });
            
           // Shuffle all options
            const finalOptions = options.sort(() => 0.5 - Math.random()).slice(0, 9);
            
            // Render options
            elements.imageOptions.innerHTML = '';
            elements.imageTarget.textContent = randomCategory;
            
            finalOptions.forEach(emoji => {
                const img = document.createElement('div');
                img.className = 'image-option';
                img.textContent = emoji;
                img.dataset.emoji = emoji;
                img.onclick = function() {
                    this.classList.toggle('selected');
                    const index = state.selectedImages.indexOf(emoji);
                    if (index === -1) {
                        state.selectedImages.push(emoji);
                    } else {
                        state.selectedImages.splice(index, 1);
                    }
                };
                elements.imageOptions.appendChild(img);
            });
            
            elements.imageCaptcha.style.display = 'block';
            elements.methodTitle.textContent = 'Image Verification';
            state.selectedImages = [];
        }
        
        function checkImageSelection() {
            if (state.selectedImages.length === 0) {
                elements.message.textContent = 'Please select at least one image';
                elements.message.className = 'message error';
                return;
            }
            
            // Check if all selected are correct and all correct are selected
            const allCorrectSelected = state.correctImages.every(emoji => 
                state.selectedImages.includes(emoji));
            const noIncorrectSelected = state.selectedImages.every(emoji => 
                state.correctImages.includes(emoji));
            
            if (allCorrectSelected && noIncorrectSelected) {
                validateResponse('correct');
            } else {
                // Count how many correct were selected
                const correctCount = state.selectedImages.filter(emoji => 
                    state.correctImages.includes(emoji)).length;
                const totalCorrect = state.correctImages.length;
                
                elements.message.textContent = `Selected ${correctCount} of ${totalCorrect} correct items`;
                elements.message.className = 'message error';
                state.attempts++;
                updateAttemptsWarning();
                initImageCaptcha(); // Reset with new images
            }
        }
        
        // Validation
        function validateResponse(response) {
            let isValid = false;
            
            switch(state.currentMethod) {
                case 'voice':
                    isValid = response === state.currentWord.toLowerCase();
                    break;
                case 'math':
                    isValid = parseInt(response) === state.mathProblem.answer;
                    break;
                case 'image':
                    isValid = response === 'correct';
                    break;
            }
            
            if (isValid) {
                elements.message.textContent = 'Verification successful!';
                elements.message.className = 'message success';
                showLoadingAndRedirect();
            } else {
                elements.message.textContent = 'Verification failed. Please try again.';
                elements.message.className = 'message error';
                state.attempts++;
                updateAttemptsWarning();
                
                if (state.attempts >= config.maxAttempts) {
                    elements.message.textContent = 'Maximum attempts reached. Please try again later.';
                    // Here you could implement a cooldown or IP blocking in a real system
                } else {
                    // Switch to a different method after failure
                    setTimeout(selectRandomMethod, 1500);
                }
            }
        }
        
        function updateAttemptsWarning() {
            if (state.attempts > 0) {
                elements.attemptsWarning.style.display = 'block';
                elements.attemptsWarning.textContent = 
                    `Attempts: ${state.attempts}/${config.maxAttempts}`;
                
                if (state.attempts >= config.maxAttempts - 1) {
                    elements.attemptsWarning.style.color = 'var(--danger)';
                } else if (state.attempts >= config.maxAttempts - 2) {
                    elements.attemptsWarning.style.color = 'var(--warning)';
                }
            } else {
                elements.attemptsWarning.style.display = 'none';
            }
        }
        
        function showLoadingAndRedirect() {
            elements.voiceCaptcha.style.display = 'none';
            elements.mathCaptcha.style.display = 'none';
            elements.imageCaptcha.style.display = 'none';
            elements.message.style.display = 'none';
            elements.loadingContainer.style.display = 'flex';
            
            setTimeout(() => {
                window.location.href = config.successRedirect;
            }, 3000);
        }
    </script>
</body>
</html>